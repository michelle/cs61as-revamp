<!-- Lab 4: Data Abstraction and Sequences -->

<p>
1.  Try these in Scheme:

<p>
<tt>  <pre>(define x (cons 4 5))
(car x)
(cdr x)
(define y (cons 'hello 'goodbye))
(define z (cons x y))
(car (cdr z))
(cdr (cdr z))
</pre></tt>

<p>
2.  Predict the result of each of these before you try it:

<p>
<tt>  <pre>(cdr (car z))
(car (cons 8 3))
(car z)
(car 3)
</pre></tt>

<p>
3.  Enter these definitions into Scheme:

<p>
<tt>  <pre>(define (make-rational num den)
  (cons num den))
(define (numerator rat)
  (car rat))
(define (denominator rat)
  (cdr rat))
(define (*rat a b)
  (make-rational (* (numerator a) (numerator b))
		 (* (denominator a) (denominator b))))
(define (print-rat rat)
  (word (numerator rat) '/ (denominator rat)))
</pre></tt>

<p>
4.  Try this:

<p>
<tt>  <pre>(print-rat (make-rational 2 3))
(print-rat (*rat (make-rational 2 3) (make-rational 1 4)))
</pre></tt>

<p>
5.  Define a procedure <tt>+rat</tt> to add two rational numbers,
in the same style as <tt>*rat</tt> above.

<p>
6.  <b>Now do exercises 2.2, 2.3, and 2.4 from <i>SICP</i>.</b>

<p>
7.  This week you'll learn that sentences are a special case of <i>lists</i>,
which are built out of pairs.  Explore how that's done with experiments such
as these:

<p>
<tt>  <pre>(define x '(a (b c) d))
(car x)
(cdr x)
(car (cdr x))
</pre></tt>

<p>
8.  <i>SICP</i> ex. 2.18; this should take some thought, and you
should make sure you get it right, but don't get stuck on it for
the whole hour.  <b>Note:</b> Your solution should reverse <i>lists</i>,
not sentences!  That is, you should be using <tt>cons</tt>, <tt>car</tt>,
and <tt>cdr</tt>, not <tt>first</tt>, <tt>sentence</tt>, etc.</p>