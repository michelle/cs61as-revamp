<!-- Homework 9: Mutable data, vectors -->

<p>
<b>Reading:</b>
Abelson &amp; Sussman, Section 3.3.1-3
<p>
(If you are a hardware type you might enjoy reading 3.3.4 even though
it isn't required.)

<p>
<b>Homework:</b>
<p>
Abelson &amp; Sussman, exercises 3.16, 3.17, 3.21, 3.25, 3.27
<p>
You don't need to draw the environment diagram for exercise 3.27;
use a trace to provide the requested explanations.
Treat the table procedures <tt>lookup</tt> and <tt>insert!</tt>&nbsp;as primitive;
i.e.&nbsp;don't trace the procedures they call.
Also, assume that those procedures work in constant time.
We're interested to know about the number of times <tt>memo-fib</tt> is
invoked.

<p>

<p>
<b>Vector questions:</b>
In all these exercises, don't use a list as an intermediate value.
(That is, don't convert the vectors to lists!)

<p>
1.  Write <tt>vector-append</tt>, which takes two vectors as arguments and
returns a new vector containing the elements of both arguments, analogous to
<tt>append</tt> for lists.

<p>
2.  Write <tt>vector-filter</tt>, which takes a predicate function and a vector
as arguments, and returns a new vector containing only those elements of the
argument vector for which the predicate returns true.  The new vector should
be exactly big enough for the chosen elements.  Compare the running time of
your program to this version:

<p>
<tt>  <pre>(define (vector-filter pred vec)
  (list-&#62;vector (filter pred (vector-&#62;list vec))))
</pre></tt>
3.  Sorting a vector.

<p>
(a) Write <tt>bubble-sort!</tt>, which takes a vector of numbers and
rearranges them to be in increasing order.  (You'll modify the
argument vector; don't create a new one.)  It uses the following
algorithm:

<p>
[1] Go through the array, looking at two adjacent elements at a
time, starting with elements 0 and 1.  If the earlier element is
larger than the later element, swap them.  Then look at the next
overlapping pair (0 and 1, then 1 and 2, etc.).

<p>
[2] Recursively bubble-sort all but the last element (which is
now the largest element).

<p>
[3] Stop when you have only one element to sort.

<p>
(b) Prove that this algorithm really does sort the vector.
Hint:  Prove the parenthetical claim in step [2].

<p>
(c) What is the order of growth of the running time of this
algorithm?

<p>
<b>Note:  Part II of programming project 3 is also due next week.</b>

<p>
<br /><hr />
Unix feature of the week: <tt>alias</tt>, <tt>unalias</tt>
<p>
Emacs feature of the week: <tt>C-x 4</tt> (split window)
<p>

<p></p>