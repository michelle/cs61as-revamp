<div id="lesson"><h2>Homework 1: Functional programming</h2></div>
<div id="lefttriangle"></div>
<div class="clear"></div>

<br />
<b>Reading:</b> <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1" target="_blank">Abelson &amp; Sussman, Section 1.1 (pages 1-31)</a>

<br />

<b>Note:</b> With the obvious exception of this first week, you should do
    each week's reading before starting the lab and homework. So also start
    now on next week's reading,
    <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3" target="_blank">Abelson &amp; Sussman, Section 1.3</a>

<br /><br />

<b>Homework:</b><br />
    People who've taken CS 3: Don't use the CS 3 higher-order procedures such as
    <tt>every</tt> in these problems; use recursion.

<ol>
<li>
    Do exercise <a
    href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_thm_1.6"
    target="_blank">1.6</a>, page 25. This is an essay question; you needn't
    hand in any computer printout, unless you think the grader can't read your
    handwriting. If you had trouble understanding the square root program in
    the book, explain instead what will happen if you use <tt>new-if</tt>
    instead of <tt>if</tt> in the <tt>pigl</tt> Pig Latin procedure.
</li>

<li>
    Write a procedure <tt>squares</tt> that takes a sentence of numbers as
    its argument and returns a sentence of the squares of the numbers:

<pre>
> (squares '(2 3 4 5)) 
(4 9 16 25)
</pre>

</li>

<li>
    Write a procedure <tt>switch</tt> that takes a sentence as its argument
    and returns a sentence in which every instance of the words <tt>I</tt> or
    <tt>me</tt> is replaced by <tt>you</tt>, while every instance of
    <tt>you</tt> is replaced by <tt>me</tt> except at the beginning of the
    sentence, where it's replaced by <tt>I</tt>. (Don't worry about
    capitalization of letters.)  Example:

<pre>
> (switch '(You told me that I should wake you up)) 
(i told you that you should wake me up)
</pre>

</li>

<li>
    Write a predicate <tt>ordered?</tt> that takes a sentence of numbers as
    its argument and returns a true value if the numbers are in ascending
    order, or a false value otherwise.
</li>

<li>
    Write a procedure <tt>ends-e</tt> that takes a sentence as its argument
    and returns a sentence containing only those words of the argument whose
    last letter is E:

<pre>
> (ends-e '(please put the salami above the blue elephant)) 
(please the above the blue) 
</pre>

</li>

<li>
    Most versions of Lisp provide <tt>and</tt> and <tt>or</tt> procedures like
    the ones on page 19. In principle there is no reason why these can't be
    ordinary procedures, but some versions of Lisp make them special forms.
    Suppose, for example, we evaluate

<pre>
(or (= x 0) (= y 0) (= z 0)) 
</pre>

    If <tt>or</tt> is an ordinary procedure, all three argument expressions
    will be evaluated before <tt>or</tt> is invoked. But if the variable
    <tt>x</tt> has the value 0, we know that the entire expression has to be
    true regardless of the values of <tt>y</tt> and <tt>z</tt>. A Lisp
    interpreter in which <tt>or</tt> is a special form can evaluate the
    arguments one by one until either a true one is found or it runs out of
    arguments.

<br /><br />

    Your mission is to devise a test that will tell you whether Scheme's
    <tt>and</tt> and <tt>or</tt> are special forms or ordinary functions. This
    is a somewhat tricky problem, but it'll get you thinking about the
    evaluation process more deeply than you otherwise might.

<br /><br />

    Why might it be advantageous for an interpreter to treat <tt>or</tt> as a
    special form and evaluate its arguments one at a time? Can you think of
    reasons why it might be advantageous to treat <tt>or</tt> as an ordinary
    function?

</li>
</ol>

    Unix feature of the week: <b>man</b> <br />
    Emacs feature of the week: <b>C-g, M-x apropos</b> <br />
    There will be a "feature of the week" each week. These first features
    come first because they are the ones that you use to find out about the
    other ones: Each provides documentation of a Unix or Emacs feature.
    This week, type man man as a shell command to see the Unix manual page
    on the man program. Then, in Emacs, type M-x (that's meta-X, or ESC X
    if you prefer) describe-function followed by the Return or Enter key,
    then apropos to see how the apropos command works. If you want to know
    about a command by its keystroke form (such as C-g) because you don't know
    its long name (such as keyboard-quit), you can say M-x describe-key then C-g. 

<br /><br />

    You aren't going to be tested on these system features,
    but it'll make the rest of your life a lot easier if you learn about them.
